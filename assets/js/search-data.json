{
  
    
        "post0": {
            "title": "Math is Fun - BIOSTAT 823 Assignment",
            "content": "This post will consist my solutions for 3 questions taken from Euler Project which they are: . 1. How many reversible numbers are there below one-billon? (ID: 145, solved by 16438 people) 2. Permuted multiples. (ID: 52, solved by 65547 people) 3. Summation of primes. (ID: 10, solved by 330347 people) . This post can be retrieved from Pu&#39;s Blog for Biostat823. And the post is auto-converted by Fastpages based on a jupyter nootebook where is kept in the Pu&#39;s BIOSTAT823 repo under the folder of _notebooks. . Repository can be accessd through this website: https://github.com/puzeng/BIOSTAT823_Blog_PuZeng. . The post can be accessed from here: https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/. . 1. How many reversible numbers are there below one-billion? . &quot;Some positive integers n have the property that the sum [ n + reverse(n) ] consists entirely of odd (decimal) digits. For instance, 36 + 63 = 99 and 409 + 904 = 1313. We will call such numbers reversible; so 36, 63, 409, and 904 are reversible. Leading zeroes are not allowed in either n or reverse(n). . There are 120 reversible numbers below one-thousand. . How many reversible numbers are there below one-billion ($10^9$)?&quot; . This is a question posted on the Euler Project which was solved by 16435 people so far. I&#39;m going to walk you through the analytical process that I took for solving the problem. . This a question that can be solved by a brute force method which means that it can be solved by checking whether the number meet the property that the sum of itself and revsersed number will only have odd digits. Below shows the brute force approach for this question. . Brute Force Approach . First, we need a helper function (is_reversible(input_number)) to identify whether the number is meeting the property or not which is the sum of itself and the reversed number only consists of odd digits. Within the helper function, if the number can be divided by 10, then the number immediately disqualified for be a reversible number. Then, we need to generate the sum of itself and the reversed number. To reverse the number, we can convert the number into a string to reverse it by using [::-1], lastly converting to integer again. . Once we generate the sum, we can check the digits of the sum by extracting each digit of the number. If the digit is an even digit, then the number is disqualified. But if the digit is odd, we keep checking on the next digit. For a number is reversible, the number can successfully go through the while loop and return True at the end line of the function. . Then, we use this helper function inside the function for counting the number of reversible numbers within a range that user defined. The count function starts with generating a list of number that is within the user defined range. Next, we are going to use a for loop to loop through the list to check each number of the list by using the helper function. If it is a reversible number, we increase the count by 1. The count function lastly will return the count which tells us how many reversible numbers within the defined range. . def is_reversible(input_number): &quot;&quot;&quot;Helper function for checking whether the numeber is reversible or not.&quot;&quot;&quot; if input_number % 10 == 0: return False reversed_number = int(str(input_number)[::-1]) sum_n_reverse = reversed_number + input_number while sum_n_reverse &gt; 0: if (sum_n_reverse % 10) % 2 == 0: return False sum_n_reverse //= 10 return True def count_reversible_numbers(input_numbers): &quot;&quot;&quot;Count the number of reversible numbers below one billion.&quot;&quot;&quot; input_list = range(input_numbers) #target_list = list() count = 0 for number in input_list: if is_reversible(number): #target_list.append(number) count += 1 #return(target_list) return count count_reversible_numbers(1000) . 120 . But since we are dealing with a range like one billion numbers, the brute force method is very insufficient in computation. Therefore, we can analyze the question by finding a pattern in the base cases. . We can approach this question by analyzing the different scenarios causing by the addition between digits. I will give detailed explanation about how this approach works in the following. . Analytical Approach . range(10^1) . In the range of numbers are in 1 digits, those number are all disqualified to be reversible since the addition of the numbers between 1-9 to itself is an even number. Therefore, we can&#39;t find any reversible number when the numbers are in 1 digit. . There is no solution. . range(10^2) . When the numbers are in 2 digits, we can use ab to represent the number in 2 digits. Then, the sum of itself and the reversed number is represented by: a+b_b+a. To meet the property, a+b must be an odd number and cannot have a carryover. In the other words, a+b &lt; 10 and a+b is an odd number. . There are 20 pairs of a and b to meet this requirement. . range(10^3) . When the numbers are in 3 digits, we us abc to represent. Then, the sum of itself and the reversed number = a+c_b+b_c+a. We can refer c+a as the outer pair and b+b as the inner pair. . Since the inner pair is the addition to itself. Like we analyzed in the 1 digit scenario, the addition to itself will always produce an even number. Therefore, the middle pair needs a 1 from the carryover of the pair c+a to become an odd number. In addition, it implies that the middle pair must not have a carryover otherwise the carryover will cause the pair a+c become an even number based on the fact that a+c needs to be an odd number. . Thus, we restrict those solutions to meet the following requirements: . b+b $ lt$ 10 and b+b is an even number. | 20 $&gt;$ a+c $&gt;$ 10 and a+c is an odd number. | Therefore, there are 5 * 20 = 100 solutions. . range(10^4) . We can use abcd to represent numbers in 4 digits. Then, the sum can be written as: a+d_b+c_c+b_d+a. We are referring a+d as the outer pair and b+c as the inner pair. . This is like the scenario that we analyzed in the 2 digits case that d+a must not have a carryover and has to be an odd number and so does the pair, c+b. However, since the pair c and b is in the middle, c+b can be 0. . Thus, the solutions need to meet those requirements: . a+d $&lt;$ 10 and a+b is an odd number. | c+b $&lt;$ 10 and c+b is an odd number and can be 0. | Therefore, there are 20*30 = 600 solutions. . range(10^5) . Numbers in 5 digits can be represented as abcde. Then, the sum = a+e_b+d_c+c_d+b_e+a. . Since c+c is the addition to itself, it will generate the even number. It also implied that c+c will borrow the 1 from the carryover of d+b. And this also tells us that a+e will take the 1 from the carryover of b+d to become an odd number. . Thus, we have the follow restrictions: . c+c is an even number. | b+d &gt; 10 and is an odd number. | a+e is an odd number. | However, there is no solution since the a+e needs to be an odd number and needs to take 1 from the carryover of b+d. . range(10^6) . Numbers in 6 digits can be represented as abcdef. The sum = a+f_b+e_c+d_d+c_e+b_f+a. . This scenario is also pretty much like the 2 digits case where: . c+d &lt; 10 and c+d can be an odd number including 0. | b+e &lt;10 and has to be an odd number including 0. | a+f &lt;10 and has to be an odd number excluding 0. | Therefore, we have 20*30^2 solutions. . range(10^7) . Numbers in 7 digits can be represented as abcdefg. The sum = a+g_b+f_c+e_d+d_e+c_f+b_g+a. . The solutions must meet the following restrictions: . d+d &lt; 10 and must be an even number. | c+e &gt; 10 and must be an odd number including 0. | f+b &lt; 10 and must be an odd number including 0. | a+g &lt; 10 and must be an odd number excluding 0. | Thus, there are 5 20 20 25 = 100 500 solutions. . range(10^8) . Numbers in 8 digits can be represented as abcdefgh. The sum = a+h_b+g_c+f_d+e_e+d_f+c_g+b_h+a. . The solutions must meet the following restrictions like the case in 2 or 4 or 6 digits: . a+h &lt; 10 and must be an odd number excluding 0. | b+g, c+f, and d+e &lt; 10 and must be an odd number including 0. | Thus, there are 20 * 30^3 solutions. . range(10^9) . Numbers in 9 digits can be represented as abcdefghi. The sum = a+i_b+h_c+g_d+f_e+e_f+d_g+c_h+b_i+a. . This case is pretty much similar like the case for 5 digits that we cannot find solutions. The reason why is that e+e needs the 1 from the carryover of d+f since the addition of e itself will only generate the even number. However, it also means that c+g, h+b are both &gt;10 and they are even numbers. Thus, since a+i has to be an odd number, a+i will be changed to even due to the carryover from b+h. . Thus, there is no solution. . Analytical Approach: Summary . Since we have done with analyzing those base cases from 1 digit to 9 digits, we can generalize the solutions based on the pattern. . For the number of digits in 1, 5, and 9, solutions = 0. For number of digits in 2, 4, 6, and 8, solutions = 20 30^n where n = # of digits / 2 - 1. For number of digits in 3 and 7, solutions = 100 500^n where n = (# of digits -3) / 4. . Based on the pattern, we can transform it into a function. . First, we need to figure out what those cases in that number range by finding the maximum numbers of digits that this numer range can hold. For that, we just need to take the log of the input number of base 10. And then, we evaluate the digit number based on the pattern that we found: . If the digit number can be divided by 2, then the count = 20 * 30^(digits/2-1). | If the digit number can be expressed as 4i+3 for i = 0,1,2,3,..., then the count = 100 500^[(digits-3)/4]. | If the digit number failed to meet the above two requirements, then there is no solution. | Below is the function for counting the number of reversible numbers within a defined number range based on analytical approach: . import math def count_reversible_nums(num_range): &quot;&quot;&quot;Count the number of the reversible numbers within a input-range.&quot;&quot;&quot; pow_number = int(math.log10(num_range)) count = 0 for power in range(2,pow_number + 1): if power % 2 == 0: count += 20 * math.pow(30 ,power / 2 - 1) if (power - 3) % 4 == 0: count += 100 * math.pow(500, (power - 3)/4) return int(count) count_reversible_nums(1000000000) . 608720 . 2. Permuted Multiples . &quot;It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order. . Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.&quot; . This is a question posted on the Euler Project which was solved by 65547 people so far (ID: 52). I&#39;m going to walk you through the process that I took for solving the problem. . We can start with number 2 and move up by 1 until the smallest positive integer that satisfies the requirement is found. To check the requirement, we need to generate several numbers that are corresponding to 2-6 times of that positive integer. . And then, a helper function will check whether the positive integer and the corresponding multiple of that number contain the same digits or not. Within the helper function, the checking process will be accomplished by comparing the two sorted numbers after converting them into strings. . Once we confirm that those multiples of that positive integer have the same digits as the positive integer itself, we will stop the increments and return to that current number. . Below is showing how the solution is coded into a function. . def same_digits(num1, num2): &quot;&quot;&quot;Helper function to check whether two numbers contain same digits.&quot;&quot;&quot; if sorted(str(num1)) == sorted(str(num2)): return True return False def permuted_multiple(): &quot;&quot;&quot;Find the smallest positive integer x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.&quot;&quot;&quot; found = False num = 2 while not found: two_times = num * 2 three_times = num * 3 four_times = num * 4 five_times = num * 5 six_times = num * 6 if (same_digits(num, two_times) and same_digits(num, three_times) and same_digits(num, four_times) and same_digits(num, five_times) and same_digits(num, six_times) ): found = True return num num += 1 return num permuted_multiple() . 142857 . 3. Summation of Primes . &quot;The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. . Find the sum of all the primes below two million.&quot; . This is a question posted on the Euler Project which was solved by 330347 people so far (ID: 10). . To approach this question, we can start with creating a list that contains every positive integers below the number range and then looping through the list to find all the primes. Since we are looping through the number list, we can exclude some integers from the list prior to the looping process to save some energy. . As we know that the prime is a number that can only be divided by 1 or itself, therefore any even number greater than 2 will automatically excluded from being a prime number since even numbers can be divided by 2. Thus, we can remove those even numbers greater than 2 from the number list. . In addition, any number ends in 5 can also be removed from the list since those numbers can be divided by 5. . Then, we will send the cleaned number list into a for loop to loop through the remainning numbers in the list and sum up all the primes in the list. . While we are looping through the number list, we will need a helper function to check whether the current number is a prime or not. If we find the prime, we will add that number to the sum. . Within the helper function, we are trying to check whether the input number is a prime or not. This is accomplished by dividing the factors of the input number into two halves. These two halves of factors are mirroring with each other if the number is not prime. We can use number 64 as the illustration. 64 can be obtained from the multiplication of the following pairs: . $1 * 64 $ | $2 * 32 $ | $4 * 16 $ | $8 * 8 $ | $16 * 4 $ | $32 * 2 $ | $64 * 1 $ | We can see that the square root of the number is the number can help to divide the factors into two halves. In addition, you may also think what if the square root of number is not an integer. We will then use the nearest integer of the square root as the mirror line. Thus, we can generate a list of factors that are below the mirror number to check whether the input number can be divided by those factors. As long as we find a factor of that number besides 1 and itself, we will return False as the indication of that number is not a prime and the function that generates the sum of the primes will increment by 1 to move to the next number in the list. . Below shows how the solution is coded into functions to solve the question: . import math def is_prime(num): &quot;&quot;&quot;Helper function to check whether the number is a prime or not.&quot;&quot;&quot; for i in range(2, int(math.sqrt(num))+1): if (num % i == 0): return False return True def sum_primes_below_num_range(num_range): &quot;&quot;&quot;Sum all the primes below the input number range.&quot;&quot;&quot; # remove all the even number above 3 but below 2 million list_nums = range(3,num_range,2) #remove all the numbers above 5 but end in 5 from the list removed_nums = range(15,num_range,10) list_nums = list(set(list_nums) - set(removed_nums)) sum = 2 for ele in list_nums: if is_prime(ele) == True: sum += ele return sum sum_primes_below_num_range(2000000) . 142913828922 .",
            "url": "https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/2021/09/03/Assignment1_PuZeng.html",
            "relUrl": "/2021/09/03/Assignment1_PuZeng.html",
            "date": " • Sep 3, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://puzeng.github.io/BIOSTAT823_Blog_PuZeng/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}